# 主包架构说明

## 概述

主包作为微前端容器，负责加载和管理所有子应用。采用 workspace 协议实现包之间的依赖管理。

## 架构设计

### 1. 包结构

```
low-code-monorepo/
├── @cwj/                    # 子包目录
│   ├── account/            # 账号中心
│   ├── admin/              # 后台管理
│   ├── designer/           # 设计器
│   └── renderer/           # 渲染器
├── src/                    # 主包源码
│   ├── router/            # 路由配置
│   ├── views/             # 容器视图
│   │   ├── Home.vue                  # 工作台首页
│   │   ├── AccountContainer.vue      # 账号中心容器
│   │   ├── AdminContainer.vue        # 后台管理容器
│   │   ├── DesignerContainer.vue     # 设计器容器
│   │   └── RendererContainer.vue     # 渲染器容器
│   ├── App.vue            # 主应用入口
│   └── main.ts            # 应用启动文件
└── package.json           # 主包配置
```

### 2. 依赖关系

主包通过 `workspace:*` 协议引用所有子包:

```json
{
  "dependencies": {
    "@cwj/account": "workspace:*",
    "@cwj/admin": "workspace:*",
    "@cwj/designer": "workspace:*",
    "@cwj/renderer": "workspace:*"
  }
}
```

### 3. 路由配置

主包路由配置 (`src/router/index.ts`):

- `/` - 工作台首页，展示所有子应用入口
- `/account` - 账号中心
- `/admin` - 后台管理
- `/designer` - 设计器
- `/renderer` - 渲染器

### 4. 容器组件

每个子应用都有对应的容器组件，负责:

1. **动态加载子应用**: 使用 `import()` 动态导入子包的 App 组件
2. **渲染子应用**: 使用 Vue 的 `component :is` 动态渲染
3. **导航控制**: 提供返回工作台的按钮

示例代码:

```vue
<script setup lang="ts">
import { ref, onMounted } from 'vue'

const accountApp = ref<any>(null)

onMounted(async () => {
  try {
    const module = await import('@cwj/account/src/App.vue')
    accountApp.value = module.default
  } catch (error) {
    console.error('加载失败:', error)
  }
})
</script>

<template>
  <component :is="accountApp" v-if="accountApp" />
</template>
```

## 工作流程

### 1. 启动流程

```
用户访问主应用
    ↓
加载主包 (main.ts)
    ↓
初始化路由和状态管理
    ↓
渲染工作台首页 (Home.vue)
    ↓
用户点击子应用卡片
    ↓
路由跳转到对应容器组件
    ↓
容器动态加载子应用
    ↓
渲染子应用内容
```

### 2. 子应用加载

1. 用户点击工作台上的应用卡片
2. 路由导航到对应的容器组件
3. 容器组件的 `onMounted` 钩子触发
4. 使用 `import()` 动态导入子包
5. 将导入的组件赋值给响应式变量
6. Vue 自动渲染子应用

## 技术特点

### 1. 按需加载

- 子应用只在需要时才加载
- 减少首屏加载时间
- 优化应用性能

### 2. 独立开发

- 每个子包可以独立开发和测试
- 互不影响，降低耦合度
- 支持团队并行开发

### 3. 统一管理

- 主包统一管理路由和状态
- 统一的用户体验
- 便于维护和升级

### 4. 类型安全

- 使用 TypeScript 保证类型安全
- Workspace 协议支持类型提示
- 编译时错误检查

## 开发指南

### 1. 安装依赖

```bash
# 使用设置脚本
chmod +x scripts/setup.sh
./scripts/setup.sh

# 或手动安装
pnpm install
```

### 2. 启动开发服务器

```bash
# 启动主应用
pnpm dev

# 启动特定子应用（独立开发）
cd @cwj/account && pnpm dev
```

### 3. 构建生产版本

```bash
# 构建主应用
pnpm build:production

# 构建特定子应用
cd @cwj/account && pnpm build:production
```

### 4. 添加新的子应用

1. 在 `@cwj/` 目录下创建新的子包
2. 在主包 `package.json` 中添加依赖:
   ```json
   "@cwj/new-app": "workspace:*"
   ```
3. 在 `vite.config.ts` 中添加别名:
   ```ts
   '@cwj/new-app': resolve(__dirname, '@cwj/new-app')
   ```
4. 创建对应的容器组件 `NewAppContainer.vue`
5. 在路由配置中添加路由
6. 在工作台首页添加应用卡片

## 注意事项

### 1. 依赖版本

- 所有子包应使用相同版本的 Vue、Vue Router 等核心依赖
- 避免版本冲突导致的问题

### 2. 样式隔离

- 使用 `scoped` 样式避免样式污染
- 子应用样式不应影响主应用

### 3. 状态管理

- 主包使用 Pinia 进行全局状态管理
- 子应用可以访问主包的状态
- 建议子应用使用独立的状态模块

### 4. 路由管理

- 主包控制顶层路由
- 子应用可以有自己的子路由
- 避免路由冲突

## 性能优化

### 1. 代码分割

- 使用动态 import 实现代码分割
- 每个子应用独立打包
- 减少主包体积

### 2. 缓存策略

- 子应用组件缓存
- 静态资源长期缓存
- 利用浏览器缓存机制

### 3. 预加载

- 可以实现子应用预加载
- 提升用户体验
- 减少等待时间

## 未来扩展

### 1. 微前端框架

- 可以升级为 qiankun 或 micro-app
- 支持更复杂的应用场景
- 更好的沙箱隔离

### 2. 应用通信

- 实现子应用间通信机制
- 事件总线或状态共享
- 统一的通信协议

### 3. 权限控制

- 基于角色的访问控制
- 动态路由权限
- 应用级权限管理

## 总结

主包作为微前端容器，通过 workspace 协议和动态导入实现了对所有子包的加载和管理。这种架构具有良好的扩展性、可维护性和性能表现，适合大型低代码平台的开发需求。
